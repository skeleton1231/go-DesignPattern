# 模板模式

模板模式的一个经典例子是实现一个报告生成器。报告可能有多种类型（如HTML、PDF、Markdown等），但报告的结构和生成过程基本相同。我们可以使用模板模式来实现这个功能。

首先，我们定义一个抽象类Report，它包含了报告生成过程中的通用方法和需要子类实现的抽象方法：

```go
package report

import (
	"fmt"
	"strings"
)

type Report interface {
	Header() string
	Body() string
	Footer() string
	GenerateReport() string
}

type ReportTemplate struct {
	Title string
	Data  []string
}

func (r *ReportTemplate) GenerateReport() string {
	header := r.Header()
	body := r.Body()
	footer := r.Footer()
	return fmt.Sprintf("%s\n%s\n%s", header, body, footer)
}
```

接下来，我们创建两个实现了Report接口的子类，分别表示HTML报告和Markdown报告：

## 1. HTML报告：

```go
package report

import (
	"fmt"
	"strings"
)

type HTMLReport struct {
	ReportTemplate
}

func (hr *HTMLReport) Header() string {
	return fmt.Sprintf("<h1>%s</h1>", hr.Title)
}

func (hr *HTMLReport) Body() string {
	lines := make([]string, len(hr.Data))
	for i, line := range hr.Data {
		lines[i] = fmt.Sprintf("<p>%s</p>", line)
	}
	return strings.Join(lines, "\n")
}

func (hr *HTMLReport) Footer() string {
	return "<footer>Generated by Report Generator</footer>"
}
```

## 2.Markdown报告:

```go
package report

import (
	"fmt"
	"strings"
)

type MarkdownReport struct {
	ReportTemplate
}

func (mr *MarkdownReport) Header() string {
	return fmt.Sprintf("# %s", mr.Title)
}

func (mr *MarkdownReport) Body() string {
	return strings.Join(mr.Data, "\n\n")
}

func (mr *MarkdownReport) Footer() string {
	return "Generated by Report Generator"
}
```

在实际业务中，我们可以根据不同的报告类型来生成不同格式的报告：

```go
package main

import (
	"fmt"
	"your_project/report"
)

func main() {
	data := []string{"Report line 1", "Report line 2", "Report line 3"}

	htmlReport := &report.HTMLReport{ReportTemplate: report.ReportTemplate{Title: "HTML Report", Data: data}}
	markdownReport := &report.MarkdownReport{ReportTemplate: report.ReportTemplate{Title: "Markdown Report", Data: data}}

	fmt.Println("HTML Report:")
	fmt.Println(htmlReport.GenerateReport())

	fmt.Println("\nMarkdown Report:")
	fmt.Println(markdownReport.GenerateReport())
}
```

### 优点：

* 模板模式提高了代码的复用性，将公共方法提取到抽象类中，避免了代码重复。
* 模板模式利用子类实现抽象方法，实现了高度的可扩展性。
* 模板模式封装了算法骨架，保持了算法结构的稳定性

### 缺点：

* 模板模式可能导致过多的子类，增加系统的复杂性。
* 当需要修改公共方法时，可能需要修改抽象类，进而影响到所有子类。

总结：

模板模式是一种行为型设计模式，它定义了一个操作中的算法骨架，将一些步骤延迟到子类中实现。这种方法让子类在不改变算法结构的情况下，重新定义某些特定步骤。通过这种方式，我们可以在一个抽象类中定义共享的行为，同时允许子类根据需求实现或重写特定的行为。

在我们的报告生成器示例中，我们使用模板模式创建了两种不同格式的报告：HTML报告和Markdown报告。我们在抽象类ReportTemplate中定义了报告生成的共享方法GenerateReport，并在子类中实现了特定格式报告的Header、Body和Footer方法。这样，我们可以轻松地添加新的报告格式，而无需修改现有的代码。

模板模式的主要优点是提高了代码的复用性和可扩展性，但同时它也可能导致过多的子类，增加系统的复杂性。在实际项目中，我们需要根据项目需求和实际情况权衡模板模式的使用。